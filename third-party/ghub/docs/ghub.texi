\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename ghub.info
@settitle Ghub User and Developer Manual
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@copying
@quotation
Copyright (C) 2017-2023 Jonas Bernoulli <jonas@@bernoul.li>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU
General Public License for more details.

@end quotation
@end copying

@dircategory Emacs
@direntry
* Ghub: (ghub).         Client library for the Github API.
@end direntry

@finalout
@titlepage
@title Ghub User and Developer Manual
@subtitle for version 3.6.0
@author Jonas Bernoulli
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Ghub User and Developer Manual

Ghub is an Emacs library that is used by various packages to access
the APIs of various instances of various Git forge implementations.

@noindent
This manual is for Ghub version 3.6.0.

@insertcopying
@end ifnottex

@menu
* Introduction::
* Getting Started::
* API::
* Notes::
* Function Index::
* Variable Index::

@detailmenu
--- The Detailed Node Listing ---

Getting Started

* Basic Concepts, Arguments and Variables: Basic Concepts Arguments and Variables. 
* Setting the Username::
* Creating and Storing a Token::
* Github Configuration Variables::

Creating and Storing a Token

* Creating a Token::
* Storing a Token::


API

* Their APIs::
* Making REST Requests::
* Making GraphQL Requests::
* Github Convenience Wrappers::
* Non-Github Convenience Wrappers::

Notes

* Using Ghub in Personal Scripts::
* Using Ghub in Your Own Package::
* Forge Limitations and Notes::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

Ghub is an Emacs library that is used by various packages to access
the APIs of various instances of various Git forge implementations.

A forge is a web-based collaborative software platform for developing
and distributing computer applications.  Examples include Github and
Gitlab.

@node Getting Started
@chapter Getting Started

This manual guides you through the steps that are necessary to use the
Forge package and/or to make a request using just Ghub itself, such as
this:

@lisp
(ghub-request "GET" "/user")
@end lisp

To be able to do that, Ghub needs to know who you want to talk to, who
you are, and how you are going to prove the latter to the former.

Additionally Ghub wants to know on behalf of which Emacs package it is
making a request.  So the question of "who is making the request" has
to be rephrased as "which human (or bot) is using what (Emacs) package
to make the request".  If for example, the human known as "tarsius" is
using the @code{forge} package, then that is represented in some places using
the string "tarsius@math{^forge}".

This package used to attempt to get the answers to these questions
using a setup wizard.  Unfortunately that had to be removed because
(a) it only ever supported Github, (b) by now Github has removed
support for that on their end, (c) it did not always work, and (d)
when it couldn't be used, or failed, then it made things @emph{more}
complicated.

So now it is necessary for users to read some documentation and
because many things can go wrong, those instructions have to be fairly
detailed.  You can of course skip over most of this, but if things go
wrong, then I would like to kindly request that you take another
look before asking me for help.

@menu
* Basic Concepts, Arguments and Variables: Basic Concepts Arguments and Variables. 
* Setting the Username::
* Creating and Storing a Token::
* Github Configuration Variables::
@end menu

@node Basic Concepts Arguments and Variables
@section Basic Concepts, Arguments and Variables

Originally Ghub supported only Github but now it also supports Gitlab,
Gitea, Gogs and Bitbucket.  For the historic reason just given, the
function @code{ghub-request} defaults to acting on a @code{github} forge, but can
be told to act on another forge using the FORGE argument.

The FORGE argument only specifies what kind of forge to act on, not
which instance.  The HOST argument can be used to select the instance.
For some forges a default instance is defined:

@itemize
@item
Forge @code{github} defaults to host @code{api.github.com}.
@item
Forge @code{gitlab} defaults to host @code{gitlab.com/api/v4}.
@item
Forge @code{bitbucket} defaults to host @code{api.bitbucket.org/2.0}.
@item
No canonical host exists for the @code{gitea} and @code{gogs} forges and
@code{localhost:3000/api/v1} is used as the default host in both cases.
@end itemize

Together the FORGE and HOST arguments specify the forge type and
instance.  In addition to that, it is also necessary to specify on
whose behalf the request is being made, which can be done using the
USERNAME and AUTH arguments.  For example:

@lisp
(ghub-request "GET" "/user" nil
              :forge 'github
              :host "api.github.com"
              :username "tarsius"
              :auth 'forge)
@end lisp

Having to specify these arguments for every request is inconvenient.
Additional variables and convenience functions can be used to make
that unnecessary in most cases.

(But for debugging purposes the above explicit form is very useful.
You will obviously have to change the value of USERNAME and you should
use @code{ghub} as AUTH when first trying this at home.)

These variables can be set globally and/or for a specific repository.

@itemize
@item
For "api.github.com" (aka the API of @uref{https://github.com}) the Git
variable @code{github.user} specifies the user.
@item
For another @code{github} instance the Git variable @code{github.HOST.user}
specifies the user.  The HOST in that variable name is the same
as the value of the HOST argument of the called function.
@item
Instead of specifying the HOST in every function call, the Git
variable @code{github.host} can be used.  This should only be set locally.
@end itemize

These @code{github} specific variables are discussed in more detail in
@ref{Github Configuration Variables}.

@noindent
For @code{gitlab} and @code{bitbucket} forges similar variables are available:

@itemize
@item
@code{gitlab.user} specifies the @uref{https://gitlab.com} user.
@item
@code{gitlab.HOST.user} specifies the user for the HOST @code{gitlab} instance.
@item
@code{gitlab.host} specifies the @code{gitlab} host, unless the HOST argument
is non-nil
@item
@code{bitbucket.user} specifies the @uref{https://bitbucket.org} user.
@item
@code{bitbucket.HOST.user} specifies the user for the HOST @code{bitbucket}
instance.
@item
@code{bitbucket.host} specifies the @code{bitbucket} host, unless the HOST
argument is non-nil.
@end itemize

For the @code{gitea} and @code{gogs} forges some similar variables are available,
however for some of the @code{ghub.*} variables no equivalent variable exist
for these two forges:

@itemize
@item
@code{gitea.user} is @strong{not} used because no canonical @code{gitea} instance exists.
@item
@code{gitea.HOST.user} specifies the user for the HOST @code{gitea} instance.
@item
@code{gitea.host} specifies the @code{gitea} host, unless the HOST argument is
non-nil
@item
@code{gogs.user} is @strong{not} used because no canonical @code{gogs} instance exists.
@item
@code{gogs.HOST.user} specifies the user for the HOST @code{gogs} instance.
@item
@code{gogs.host} specifies the @code{gogs} host, unless the HOST argument is
non-nil
@end itemize

@node Setting the Username
@section Setting the Username

Ghub needs to know your username that you use on the host that you
want it to connect to.  For each host a different Git variable has to
be set to specify the username on that host.  More than one variable
is needed because you might use different usernames on different
hosts.

@anchor{Setting your Githubcom Username}
@subheading Setting your Github.com Username

To inform Ghub about your "github.com" username do this:

@example
git config --global github.user USERNAME
@end example

If you need to identify as another user in a particular repository,
then you have to set that variable locally:

@example
cd /path/to/repo
git config --local github.user USERNAME
@end example

@anchor{Setting your Gitlabcom Username}
@subheading Setting your Gitlab.com Username

To inform Ghub about your "gitlab.com" username do this:

@example
git config --global gitlab.user USERNAME
@end example

If you need to identify as another user in a particular repository,
then you have to set that variable locally:

@example
cd /path/to/repo
git config --local gitlab.user USERNAME
@end example

Make sure you use the correct USERNAME for this forge/host.  It might
not be the same as on "github.com"!

@anchor{Setting your Github Enterprise Username}
@subheading Setting your Github Enterprise Username

For Github Enterprise instances you have to specify where the API
can be accessed and a different variable has to be used to set the
username.

For example if the API is available at @code{https://example.com/api/v3},
then you should do this:

@example
git config --global github.example.com/api/v3.user USERNAME
@end example

Make sure you use the correct USERNAME for this instance.  It might
not be the same as on "github.com"!

Doing this only tells Ghub who you are on this host, additionally you
have to tell Ghub which repositories are connected to that forge/host,
like so:

@example
cd /path/to/repo
git config --local github.host example.com/api/v3
@end example

@anchor{Setting your Username for Other Hosts and/or Forges}
@subheading Setting your Username for Other Hosts and/or Forges

To inform Ghub about your username on HOST (a FORGE instance) do this:

@example
git config --global FORGE.HOST.user USERNAME
@end example

FORGE can be one of @code{bitbucket}, @code{gitea} or @code{gogs}.  It can also be @code{github} or
@code{gitlab}; but if that is the case, then you should look at the preceding
sections instead, which discuss these cases specifically.

HOST identifies the instance.  This actually points at the top-level
endpoint of the API and may contain path components, e.g.:
@code{example.com/api}.

If you need to identify as another user in a particular repository,
then you have to set that variable locally:

@example
cd /path/to/repo
git config --local FORGE.HOST.user USERNAME
@end example

@node Creating and Storing a Token
@section Creating and Storing a Token

@menu
* Creating a Token::
* Storing a Token::
@end menu

@node Creating a Token
@subsection Creating a Token

To create a token, use the web interface of the forge/host you want to
connect to.  Here is a list of pages to do this for certain popular
hosts:

@itemize
@item
@uref{https://github.com/settings/tokens}
@item
@uref{https://gitlab.com/-/profile/personal_access_tokens}
@end itemize

For other forges we cannot provide a functioning URL because they
contain unknown values such as your name.  Just go to the general
settings page of the respective host and then go from there.

Except on @code{gitea} and @code{gogs} each token can be limited to certain
"scopes", i.e., it is possible to limit for which purposes any given
token can be used.

Before you create a token to be used for a certain package, you should
consult the documentation of that package, which in turn should tell
you which scopes are needed and why.  The Forge package for example
does so in @ref{Token Creation,,,forge,}.

@node Storing a Token
@subsection Storing a Token

Please also see @ref{Top,,,auth,} for all the gory details about Auth-Source.

The variable @code{auth-sources} controls how and where Auth-Source keeps its
secrets.  The default value is a list of three files: @code{("~/.authinfo"
"~/.authinfo.gpg" "~/.netrc")}, but to avoid confusion you should make
sure that only one of these files exists and then you should also
adjust the value of the variable to only ever use that file, for
example:

@lisp
(setq auth-sources '("~/.authinfo"))
@end lisp

In @code{~/.authinfo} secrets are stored in plain text.  If you don't want
that, then you should use the encrypted @code{~/.authinfo.gpg} instead:

@lisp
(setq auth-sources '("~/.authinfo.gpg"))
@end lisp

Auth-Source also supports storing secrets in various external
key-chains.  See @ref{Top,,,auth,} for more information.

The default Auth-Source backends only support storing three values per
entry; the "machine", the "login" and the "password".  Because Ghub
uses separate tokens for each package, it has to squeeze four values
into those three slots, and it does that by using "USERNAME@math{^PACKAGE}"
as the "login".

Assuming your @strong{Github} username is "ziggy", the package is named
"forge", and you want to access @strong{Github.com} with the @strong{token}
"012345abcdef@dots{}", an entry in one of the three mentioned files
would then look like this:

@example
machine api.github.com login ziggy^forge password 012345abcdef...
@end example

Assuming your @strong{Gitlab} username is "ziggy", the package is named
"forge", and you want to access @strong{Gitlab.com} with the @strong{token}
"012345abcdef@dots{}", an entry in one of the three mentioned files
would then look like this:

@example
machine gitlab.com/api/v4 login ziggy^forge password 012345abcdef...
@end example

@node Github Configuration Variables
@section Github Configuration Variables

The username and, unless you only use Github.com itself, the Github
Enterprise instance have to be configured using Git variables.  In
rare cases it might also be necessary to specify the identity of the
local machine, which is done using a lisp variable.

@defvar github.user
The Github.com username.  This should be set globally and if you
have multiple Github.com user accounts, then you should set this
locally only for those repositories that you want to access using
the secondary identity.
@end defvar

@defvar github.HOST.user
This variable serves the same purpose as @code{github.user} but for the
Github Enterprise instance identified by @code{HOST}.

The reason why separate variables are used is that this makes it
possible to set both values globally instead of having to set one of
the values locally in each and every repository that is connected to
the Github Enterprise instance, not Github.com.
@end defvar

@defvar github.host
This variable should only be set locally for a repository and
specifies the Github Enterprise edition that that repository is
connected to.  You should not set this globally because then each
and every repository becomes connected to the specified Github
Enterprise instance, including those that should actually be
connected to Github.com.

When this is undefined, then "api.github.com" is used (defined in
the constant @code{ghub-default-host}, which you should never attempt to
change.)
@end defvar

@node API
@chapter API

@menu
* Their APIs::
* Making REST Requests::
* Making GraphQL Requests::
* Github Convenience Wrappers::
* Non-Github Convenience Wrappers::
@end menu

@node Their APIs
@section Their APIs

Of course this manual does not cover the APIs of all forges that it
supports, but for your convenience, here are the links to their API
manuals:

@itemize
@item
Github:
@itemize
@item
@uref{https://developer.github.com/v4} (GraphQl)
@item
@uref{https://developer.github.com/v3} (REST)
@end itemize
@item
Gitlab:
@itemize
@item
@uref{https://docs.gitlab.com/ee/api/README.html}
@end itemize
@item
Gitea:
@itemize
@item
@uref{https://docs.gitea.io/en-us/api-usage}
@item
@uref{https://try.gitea.io/api/swagger}
@end itemize
@item
Gogs:
@itemize
@item
@uref{https://github.com/gogs/go-gogs-client/wiki}
@end itemize
@item
Bitbucket:
@itemize
@item
@uref{https://developer.atlassian.com/bitbucket/api/2/reference}
@end itemize
@end itemize

@node Making REST Requests
@section Making REST Requests

@defun ghub-request method resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback url value error extra method*
This function makes a request for @code{RESOURCE} using @code{METHOD}.
@code{PARAMS}, @code{QUERY}, @code{PAYLOAD} and/or @code{HEADERS} are alists holding
additional request data.  The response body is returned and the
response headers are stored in the variable @code{ghub-response-headers}.

@itemize
@item
@code{METHOD} is the HTTP method, given as a string.
@item
@code{RESOURCE} is the resource to access, given as a string beginning
with a slash.

@item
@code{PARAMS}, @code{QUERY}, @code{PAYLOAD} and @code{HEADERS} are alists and are used
to specify request data.  All these arguments are alists that
resemble the JSON expected and returned by the Github API@.  The
keys are symbols and the values stored in the @code{cdr} (not the
@code{cadr}) can be strings, integers, or lists of strings and
integers.

The Github API documentation is vague on how data has to be
transmitted and for a particular resource usually just talks about
"parameters".  Generally speaking when the @code{METHOD} is "HEAD" or
"GET", then they have to be transmitted as a query, otherwise as a
payload.

@itemize
@item
Use @code{PARAMS} to automatically transmit like @code{QUERY} or @code{PAYLOAD}
would depending on @code{METHOD}.
@item
Use @code{QUERY} to explicitly transmit data as a query.
@item
Use @code{PAYLOAD} to explicitly transmit data as a payload.  Instead
of an alist, @code{PAYLOAD} may also be a string, in which case it
gets encoded as UTF-8 but is otherwise transmitted as-is.
@item
Use @code{HEADERS} for those rare resources that require that the
data is transmitted as headers instead of as a query or payload.
When that is the case, then the Github API documentation usually
mentions it explicitly.
@end itemize

@item
If @code{SILENT} is non-nil, then progress reports and the like are not
messaged.

@item
If @code{UNPAGINATE} is t, then this function makes as many requests as
necessary to get all values.  If @code{UNPAGINATE} is a natural number,
then it gets at most that many pages.  For any other non-nil value
it raises an error.

@item
If @code{NOERROR} is non-nil, then no error is raised if the request
fails and @code{nil} is returned instead.  If @code{NOERROR} is @code{return},
then the error payload is returned instead of @code{nil}.

@item
If @code{READER} is non-nil, then it is used to read and return from
the response buffer.  The default is @code{ghub--read-json-payload}.
For the very few resources that do not return JSON, you might want
to use @code{ghub--decode-payload}.

@item
If @code{USERNAME} is non-nil, then the request is made on behalf of
that user.  It is better to specify the user using the Git
variable @code{github.user} for "api.github.com", or @code{github.HOST.user}
if connecting to a Github Enterprise instance.

@item
Each package that uses Ghub should use its own token.  If @code{AUTH}
is @code{nil} or unspecified, then the generic @code{ghub} token is used
instead.  This is only acceptable for personal utilities.  A
package that is distributed to other users should always use this
argument to identify itself, using a symbol matching its name.

Package authors who find this inconvenient should write a wrapper
around this function and possibly for the method-specific
functions as well.

Beside @code{nil}, some other symbols have a special meaning too.
@code{none} means to make an unauthorized request.  @code{basic} means to
make a password based request.  If the value is a string, then it
is assumed to be a valid token.  @code{basic} and an explicit token
string are only intended for internal and debugging uses.

If @code{AUTH} is a package symbol, then the scopes are specified using
the variable @code{AUTH-github-token-scopes}.  It is an error if that
is not specified.  See @code{ghub-github-token-scopes} for an example.

@item
If @code{HOST} is non-nil, then connect to that Github instance.
This defaults to "api.github.com".  When a repository is connected
to a Github Enterprise instance, then it is better to specify that
using the Git variable @code{github.host} instead of using this
argument.

@item
If @code{FORGE} is @code{gitlab}, then connect to Gitlab.com or, depending
on @code{HOST}, to another Gitlab instance.  This is only intended for
internal use.  Instead of using this argument you should use
function @code{glab-request} and other @code{glab-*} functions.

@item
If @code{CALLBACK} and/or @code{ERRORBACK} is non-nil, then this function makes
one or more asynchronous requests and calls @code{CALLBACK} or @code{ERRORBACK}
when finished.  If no error occurred, then it calls @code{CALLBACK},
unless that is @code{nil}.

If an error occurred, then it calls @code{ERRORBACK}, or if that is nil,
then @code{CALLBACK}.  @code{ERRORBACK} can also be @code{t}, in which case it signals
instead.  @code{NOERROR} is ignored for all asynchronous requests.

Both callbacks are called with four arguments.

@enumerate
@item
For @code{CALLBACK}, the combined value of the retrieved pages.
For @code{ERRORBACK}, the error that occurred when retrieving the
last page.
@item
The headers of the last page as an alist.
@item
Status information provided by @code{url-retrieve}.  Its @code{:error}
property holds the same information as the first argument to
@code{ERRORBACK}.
@item
A @code{ghub--req} struct, which can be passed to @code{ghub-continue}
(which see) to retrieve the next page, if any.
@end enumerate
@end itemize
@end defun

@defun ghub-continue args
If there is a next page, then this function retrieves that.

This function is only intended to be called from callbacks.  If
there is a next page, then that is retrieved and the buffer that
the result will be loaded into is returned, or t if the process
has already completed.  If there is no next page, then return nil.

Callbacks are called with four arguments (see @code{ghub-request}).
The forth argument is a @code{ghub--req} struct, intended to be passed
to this function.  A callback may use the struct's @code{extra} slot
to pass additional information to the callback that will be called
after the next request.  Use the function @code{ghub-req-extra} to get
and set the value of that slot.

As an example, using @code{ghub-continue} in a callback like so:

@lisp
(ghub-get "/users/tarsius/repos" nil
          :callback (lambda (value _headers _status req)
                      (unless (ghub-continue req)
                        (setq my-value value))))
@end lisp

is equivalent to:

@lisp
(ghub-get "/users/tarsius/repos" nil
          :unpaginate t
          :callback (lambda (value _headers _status _req)
                      (setq my-value value)))
@end lisp

To demonstrate how to pass information from one callback to the
next, here we record when we start fetching each page:

@lisp
(ghub-get "/users/tarsius/repos" nil
          :extra (list (current-time))
          :callback (lambda (value _headers _status req)
                      (push (current-time) (ghub-req-extra req))
                      (unless (ghub-continue req)
                        (setq my-times (ghub-req-extra req))
                        (setq my-value value))))
@end lisp
@end defun

@defvar ghub-response-headers
A select few Github API resources respond by transmitting data in
the response header instead of in the response body.  Because there
are so few of these inconsistencies, @code{ghub-request} always returns
the response body.

To access the response headers use this variable after @code{ghub-request}
has returned.
@end defvar

@defun ghub-response-link-relations req headers payload
This function returns an alist of the link relations in @code{HEADERS}, or
if optional @code{HEADERS} is nil, then those in @code{ghub-response-headers}.

When accessing a Bitbucket instance then the link relations are in
@code{PAYLOAD} instead of @code{HEADERS}, making their API merely RESTish and
forcing this function to append those relations to the value of
@code{ghub-response-headers}, for later use when this function is called
with @code{nil} for @code{PAYLOAD}.
@end defun

@node Making GraphQL Requests
@section Making GraphQL Requests

@defun ghub-graphql graphql &optional variables &key username auth host callback silent callback errorback value extra
This function makes a GraphQL request using @code{GRAPHQL} and
@code{VARIABLES} as inputs.  @code{GRAPHQL} is a GraphQL string.  @code{VARIABLES}
is a JSON-like alist.  The other arguments behave as for
@code{ghub-request} (which see).

The response is returned as a JSON-like alist.  Even if the response
contains @code{errors}, this function does not raise an error.
Cursor-handling is likewise left to the caller.
@end defun

@code{ghub-graphql} is a thin convenience wrapper around @code{ghub-request},
similar to @code{ghub-post} and friends.  While the latter only hard-code
the value of the @code{METHOD} argument, the former also hard-codes @code{RESOURCE}
and constructs @code{PAYLOAD} from @code{GRAPHQL} and @code{VARIABLES}.  It also drops
@code{UNPAGINATE}, @code{NOERROR}, @code{READER} (internal functions expect alist-ified
JSON) and @code{FORGE} (only Github currently supports GraphQL).

@code{ghub-graphql} does not account for the fact that pagination works
differently in GraphQL than it does in REST, so users of this function
have to deal with that themselves.  Likewise error handling works
differently and has to be done by the caller too.

An early attempt at implementing automatic unpaginating for GraphQL
can be found in the @code{faithful-graphql} branch, provided I haven't
deleted that by now.  On that branch I try to do things as intended by
the designers of GraphQL, using variables and fragments, and drowning
in a sea of boilerplate.

The problem with that approach is that it only works for applications
that fetch specific information on demand and actually want things to
be paginated.  I am convinced that GraphQL is very nice for web apps.

However the Forge package for which I have implemented all of this has
very different needs.  It wants to fetch "all the data" and "cache"
it locally, so that it is available even when there is no internet
connection.  GraphQL was designed around the idea that you should be
able to "ask for what you need and get exactly that".  But when that
boils down to "look, if I persist, then you are going to hand me over
all the data anyway, so just caught it up already", then things start
to fall apart.  If Github's GraphQL allowed pagination to be turned
off completely, then teaching @code{ghub-graphql} about error handling would
be enough.

But it doesn't and when doing things as intended, then that leads to
huge amounts of repetitive boilerplate, which is so boring to write
that doing it without introducing bugs left and right is near
impossible; so I decided to give up on GraphQL variables, fragments
and conditions, and instead implement something more powerful, though
also more opinionated.

@defun ghub--graphql-vacuum query variables callback &optional until &key narrow username auth host forge
This function is an opinionated alternative to @code{ghub-graphql}.
It relies on dark magic to get the job done.

It makes an initial request using @code{QUERY}.  It then looks for
paginated edges in the returned data and makes more requests to
resolve them.  In order to do so it automatically transforms the
initial @code{QUERY} into another query suitable for that particular edge.
The data retrieved by subsequent requests is then injected into the
data of the original request before that is returned or passed to
the callback.  If subsequently retrieved data features new paginated
edges, then those are followed recursively.

The end result is essentially the same as using @code{ghub-graphql}, if
only it were possible to say "do not paginate anything".  The
implementation is much more complicated because it is not possible
to do that.

@code{QUERY} is a GraphQL query expressed as an s-expression.  The bundled
@code{gsexp} library is used to turn that into a GraphQL query string.
Only a subset of the GraphQL features are supported; fragments for
example are not, and magical stuff happens to variables.  This is
not documented yet, I am afraid.  Look at existing callers.

@code{VARIABLES} is a JSON-like alist as for @code{ghub-graphql}.

@code{UNTIL} is an alist @code{((EDGE-until . VALUE)...)}.  When unpaginating @code{EDGE}
try not to fetch beyond the element whose first field has the value
@code{VALUE} and remove that element as well as all "lesser" elements from
the retrieved data if necessary.  Look at @code{forge--pull-repository} for
an example.  This is only useful if you "cache" the response locally
and want to avoid fetching data again that you already have.

Other arguments behave as for @code{ghub-graphql} and @code{ghub-request}, more or
less.  If @code{CALLBACK} is nil, pretty-print the response.
@end defun

Using @code{ghub--graphql-vacuum}, the following resource specific functions
are implemented.  These functions are not part of the public API yet
and are very much subject to change.

@defun ghub-fetch-repository owner name callback &optional until &key username auth host forge
This function asynchronously fetches forge data about the specified
repository.  Once all data has been collected, @code{CALLBACK} is called
with the data as the only argument.
@end defun

@defun ghub-fetch-issue owner name callback &optional until &key username auth host forge
This function asynchronously fetches forge data about the specified
issue.  Once all data has been collected, @code{CALLBACK} is called
with the data as the only argument.
@end defun

@defun ghub-fetch-pullreq owner name callback &optional until &key username auth host forge
This function asynchronously fetches forge data about the specified
pull-request.  Once all data has been collected, @code{CALLBACK} is called
with the data as the only argument.
@end defun

Note that in order to avoid duplication all of these functions base
their initial query on the query stored in @code{ghub-fetch-repository}.  The
latter two pass that query through @code{ghub--graphql-prepare-query}, which
then uses @code{ghub--graphql-narrow-query} to remove parts the caller is not
interested in.  These two functions are also used internally, when
unpaginating, but as demonstrated here they can be useful even before
making an initial request.

@node Github Convenience Wrappers
@section Github Convenience Wrappers

@defun ghub-head resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun ghub-get resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
These functions are simple wrappers around @code{ghub-request}.  Their
signature is identical to that of the latter, except that they do
not have an argument named @code{METHOD}.  The HTTP method is instead
given by the second word in the function name.

As described in the documentation for @code{ghub-request}, it depends on
the used method whether the value of the @code{PARAMS} argument is used
as the query or the payload.  For the "HEAD" and "GET" methods it
is used as the query.
@end defun

@defun ghub-put resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun ghub-post resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun ghub-patch resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun ghub-delete resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
These functions are simple wrappers around @code{ghub-request}.  Their
signature is identical to that of the latter, except that they do
not have an argument named @code{METHOD}.  The HTTP method is instead
given by the second word in the function name.

As described in the documentation for @code{ghub-request}, it depends on
the used method whether the value of the @code{PARAMS} argument is used
as the query or the payload.  For the "PUT", "POST", "PATCH" and
"DELETE" methods it is used as the payload.
@end defun

@defun ghub-wait resource &optional duration &key username auth host
Some API requests result in an immediate successful response even
when the requested action has not actually been carried out yet.
An example is the request for the creation of a new repository,
which doesn't cause the repository to immediately become available.
The Github API documentation usually mentions this when describing
an affected resource.

If you want to do something with some resource right after making
a request for its creation, then you might have to wait for it to
actually be created.  This function can be used to do so.  It
repeatedly tries to access the resource until it becomes available
or until a timeout is reached.  In the latter case it signals
@code{ghub-error}.

@code{RESOURCE} specifies the resource that this function waits for.

@code{DURATION} specifies the maximum number of seconds to wait for,
defaulting to 64 seconds.  Emacs will block during that time, but
the user can abort using @code{C-g}.

The first attempt is made immediately and will often succeed.  If
not, then another attempt is made after two seconds, and each
subsequent attempt is made after waiting as long as we already
waited between all preceding attempts combined.

See @code{ghub-request}'s documentation above for information about the
other arguments.
@end defun

@node Non-Github Convenience Wrappers
@section Non-Github Convenience Wrappers

@code{ghub-request} and @code{ghub-METHOD} can be used to make a request for any
of the supported forge types, but except when making a request for
a @code{github} instance, then that requires the use of the FORGE argument.

To avoid that, functions named @code{FORGE-request} and @code{FORGE-METHOD} are also
available.  The following forms are equivalent, for example:

@lisp
(ghub-get ... :auth 'PACKAGE :forge 'gitlab)
(glab-get ... :auth 'PACKAGE)
@end lisp

These forms would remain equivalent even if you did not specify a
value for the AUTH arguments — but you should not do that if you plan
to share your code with others (see @ref{Using Ghub in Your Own Package}).
If you do omit AUTH, then the request is made on behalf of the @code{ghub}
package, @strong{regardless} of the symbol prefix of the function you use to do
so.

All @code{FORGE-request} and @code{FORGE-METHOD} functions, including but not
limited to @code{ghub-METHOD}, are very simple wrappers around @code{ghub-request}.
They take fewer arguments than @code{ghub-request} and instead pass constant
values for the arguments METHOD and/or FORGE@.

@defun buck-request resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-request resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gogs-request resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
Wrappers around @code{ghub-request} which hardcode the FORGE to either
@code{bitbucket}, @code{gitlab}, @code{gogs} or @code{gitea}.
@end defun

@defun buck-get resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun buck-put resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun buck-post resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun buck-delete resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-head resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-get resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-put resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-post resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-patch resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun glab-delete resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gogs-get resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gogs-put resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gogs-post resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gogs-patch resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gogs-delete resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gtea-get resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gtea-put resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gtea-post resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gtea-patch resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
@end defun
@defun gtea-delete resource &optional params &key query payload headers unpaginate noerror reader username auth host callback errorback
Wrappers around @code{FORGE-METHOD} which hardcode the FORGE to either
@code{bitbucket}, @code{gitlab}, @code{gogs} or @code{gitea}, and the METHOD to the implied
method.

Note that @code{buck-head}, @code{buck-patch}, @code{gogs-head} and @code{gtea-head} do not exist
because the respective APIs do not appear to support these methods.
@end defun

@node Notes
@chapter Notes

@menu
* Using Ghub in Personal Scripts::
* Using Ghub in Your Own Package::
* Forge Limitations and Notes::
@end menu

@node Using Ghub in Personal Scripts
@section Using Ghub in Personal Scripts

You can of course use @code{ghub-request} and its wrapper functions in your
personal scripts.  Unlike when you use Ghub in a package that you
distribute for others to use, you don't have to explicitly specify a
package in personal scripts.

@lisp
;; This is perfectly acceptable in personal scripts ...
(ghub-get "/user")

;; ... and actually equals to
(ghub-get "/user" nil :auth 'ghub)

;; In packages you have to specify the package using AUTH.
(ghub-get "/user" nil :auth 'some-package)
@end lisp

When the @code{AUTH} argument is not specified, then a request is made on
behalf of the @code{ghub} package itself.  Like for any other package you
have to create a dedicated token of coures.

@node Using Ghub in Your Own Package
@section Using Ghub in Your Own Package

Every package should use its own token.  This allows you as the author
of some package to only request access to API scopes that are actually
needed, which in turn might make it easier for users to trust your
package not to do unwanted things.

You have to tell @code{ghub-request} on behalf of which package a request is
being made by passing the symbol @code{PACKAGE} as the value of its @code{AUTH}
argument.

@lisp
(ghub-request "GET" "/user" nil :auth 'PACKAGE)
@end lisp

Keep in mind that the users of your package will have to manually
create a suitable token.  To make that easier, you should not only
link to this manual but also prominently mention the scopes the token
needs; and explain what they are needed for.

@node Forge Limitations and Notes
@section Forge Limitations and Notes

@itemize
@item
There are no default Gitea and Gogs instances so the variables
@code{gitea.host} and @code{gogs.host} are not taken into account.

@item
Gitea and Gogs do not support limiting a token to certain scopes.

@item
The Bitbucket API is fairly broken and my willingness to deal with
that is extremely limited unless someone pays me vast amounts of
money.

@item
The Gitlab API documentation is not always accurate, though I don't
have an example at hand.  It also isn't structured well, making it
occasionally difficult to find the information one is looking for.

@item
Where one would use @code{user/repo} when accessing another forge, one has
to use @code{user%2Frepo} when accessing Gitlab, e.g.:

@lisp
(glab-get "/projects/python-mode-devs%2Fpython-mode")
@end lisp
@end itemize

@node Function Index
@appendix Function Index

@printindex fn

@node Variable Index
@appendix Variable Index

@printindex vr

@bye
