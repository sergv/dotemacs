;;; lsp-isar-output.el --- Update the state and output buffers -*- lexical-binding: t -*-

;; Copyright (C) 2018-2020 Mathias Fleury

;; Author: Mathias Fleury <mathias.fleury@protonmail.com>
;; URL: https://bitbucket.org/zmaths/isabelle2019-vsce/

;; Keywords: lisp
;; Version: 0

;; Permission is hereby granted, free of charge, to any person obtaining a copy
;; of this software and associated documentation files (the "Software"), to deal
;; in the Software without restriction, including without limitation the rights
;; to use, copy, modify, merge, publish, distribute, sublicense, and-or sell
;; copies of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be included in
;; all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

;;; Commentary:

;; Provides two ways to update the output and state buffer.  Once directly and another
;; asynchronously via the async library.

;;; Code:

(eval-when-compile
  (require 'macro-util))

(require 'isar-goal-mode)
(require 'lsp-isar-decorations)
(require 'dash)

(require 'dom)
(require 'lsp-protocol)
(require 'lsp-isar-types)

(eval-when-compile (require 'subr-x))

(defvar lsp-isar-output-buffer nil "Isabelle output buffer.")
(defvar lsp-isar-output-proof-cases-content nil)
(defvar lsp-isar-output-proof-timer nil "Current timer rendering the HTML.")

(defvar lsp-isar-output-current-output-number 0 "Number of the current output.")
(defvar lsp-isar-output-last-seen-prover nil "Name of the prover that was seen last.")

(defcustom lsp-isar-output-use-async nil
  "Use asynchronous goal printing."
  :type '(bool)
  :group 'isabelle)

(defcustom lsp-isar-output-time-before-printing-goal 0.3
  "Time before printing goal.  Use nil to avoid printing."
  :type '(number)
  :group 'isabelle)

(defun lsp-isar-output-remove-quotes-from-string (str)
  (if (string= str "''")
      ""
    (let ((len (length str)))
      (pcase len
        (`0 str)
        (`1 str)
        (_
         (let* ((last (1- len))
                (start (if (char= (aref str 0) ?\')
                           1
                         0))
                (end (if (char= (aref str last) ?\')
                         last
                       len)))
           (substring str start end)))))))

;; The function iterates over the HTML as parsed by the HTML library.  As a side effect, it fills the
;; state buffer and the output buffer with the correct faces.  We cannot make the function recursive,
;; as recursive is slower and fail for deep goals.
;;
;; To shorten the code, we use the define-inline which is inlined
;; during compilation.
;;
;;
;; TODO
;;
;;   - find a big example to play with the recursive function to
;; optimise the code.
;;
;;   - find a proper profiling library.
;;
;;   - don't always use the async version of the printing.  At least for small goals, it should be
;; faster to use the local instance.
;;
;;  - deduplicate functions
;;
;; The (cond ...) compiles down to a jump table, except for the
;; entries that contains (or (eq ...) (eq ...)).  Therefore, I
;; duplicate entries.
;;
;;
;; RESULT OF SOME INVESTIGATIONS
;;
;;   - parsing the goal is not slow during testing but can become a
;; huge issue on Isabelle theories.  And profiling in Emacs is as usual
;; entirely useless to find the problem.
;;
;;
;; Initially, to reduce the overhead of printing (especially when the output contains an error).  The
;; typical situation is that "apply aut" is typed, which means that goal is printer once and another
;; time in the error message.  This is impossible to support.  Therefore, we delay the printing, such
;; that we can cancel it, if another newer version of the goal is coming.  The delay was
;; experimentally set to 0.3s.  If async is used, the processing is moved to another Emacs
;; instance.  We currently do not use any delay, although printing still has a cost on the local
;; Emacs.
;;
;; The choice of async is rather random, but there are not that many options and the
;; documentation is good enough...
;;
(defun lsp-isar-output-parse-output (contents)
  "Parse Isabelle output CONTENTS.

The function iterates over the dynamic output generated by
Isabelle (after preprocessing), in order to generate a goal that
must be printed in Emacs with the syntax highlighting.

This is function is important for performance (not as critical as
the decorations), because goals can become arbitrary long.  Remark
that I have not really tried to optimise it yet.  Even if the
function is less critical, Emacs is single threaded and all these
functions adds up.  So any optimisation would help."
  (let ((decorations nil))
    (while contents
      (let ((content (pop contents)))
        ;; (message "content = %s" content)
        (cond
          ((eq content nil) nil)
          ((eq content 'html) nil)
          ((stringp content) (insert content))
          ((not (listp content))
	   ;; (message "unrecognised %s" content)
	   (insert (format "%s" content)))
          (t
           (pcase (car content)
	     ('lsp-isar-output-fontification
	      (let ((start-point (cadr content))
		    (face (cddr content)))
	        (push (list start-point (point) face) decorations)))
	     ('lsp-isar-output-save-sendback
	      (let ((start-point (cadr content)))
	        (push (buffer-substring-no-properties start-point (point)) lsp-isar-output-proof-cases-content)))
             (_
	      (pcase (dom-tag content)
	        ('html
	         (setq contents (append (dom-children content) contents)))
	        ('xmlns nil)
	        ('meta nil)
	        ('link nil)
	        ('xml_body nil)
	        ('path nil)

	        ('head
	         (push (car (last (dom-children content))) contents))

	        ('body
	         (setq contents (append (dom-children content) contents)))

	        ('block
	            (when (dom-attr content 'indent) (insert-char ?\s))
	          (setq contents (append (dom-children content) contents)))

	        ('class
	         (setq contents (append (dom-children content) contents)))

	        ('pre
	         (setq contents (append (dom-children content) contents)))

	        ('state_message
	         (push (dom-node 'break `(('line . 1)) "\n") contents)
	         (setq contents (append (dom-children content) contents)))

	        ('information_message
	         (let ((start-point (point)) (face 'lsp-isar-font-dotted-information))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('tracing_message ;; TODO Proper colour
	         (let ((start-point (point)) (face 'lsp-isar-font-dotted-information))
	           (push (dom-node 'break `(('line . 1)) "\n") contents)
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('warning_message
	         (let ((start-point (point)) (face 'lsp-isar-font-text-overview-warning))
	           (push (dom-node 'break `(('line . 1)) "\n") contents)
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('legacy_message
	         (let ((start-point (point)) (face 'lsp-isar-font-text-overview-warning))
	           (push (dom-node 'break `(('line . 1)) "\n") contents)
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('writeln_message
	         (let ((start-point (point)) (face 'lsp-isar-font-dotted-writeln))
	           (push (dom-node 'break `(('line . 1)) "\n") contents)
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('error_message
	         (let ((start-point (point)) (face 'lsp-isar-font-text-overview-error))
	           (push (dom-node 'break `(('line . 1)) "\n") contents)
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('b
	         (insert "\\<^bbold>")
	         (setq contents (append (dom-children content) (list "\\<^ebold>") contents)))

	        ('i
	         (insert "\\<^bitalic>")
	         (setq contents (append (dom-children content) (list "\\<^eitalic>") contents)))

	        ('text_fold
	         (setq contents (append (dom-children content) contents)))

	        ('subgoal
	         (setq contents (append (dom-children content) contents)))

	        ('span
	         (let ((str (format "%s" (car (last (dom-children content))))))
                   (insert str)))
	        ('position
	         (push (car (last (dom-children content))) contents))

	        ('intensify
	         (let ((start-point (point)) (face 'lsp-isar-font-background-intensify))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('keyword1
	         (let ((start-point (point)) (face 'lsp-isar-font-text-keyword1))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('keyword2
	         (let ((start-point (point)) (face 'lsp-isar-font-text-keyword2))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('keyword3
	         (let ((start-point (point)) (face 'lsp-isar-font-text-keyword3))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('keyword4
	         (let ((start-point (point)) (face 'lsp-isar-font-text-keyword4))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('fixed ;; this is used to enclose other variables
	         (setq contents (append (dom-children content) contents)))

	        ('free
	         (let ((start-point (point)) (face 'lsp-isar-font-text-free))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('inner_string ;; TODO font
	         (setq contents (append (dom-children content) contents)))

	        ('tfree
	         (let ((start-point (point)) (face 'lsp-isar-font-text-tfree))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('tvar
	         (let ((start-point (point)) (face 'lsp-isar-font-text-tvar))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('var
	         (let ((start-point (point)) (face 'lsp-isar-font-text-var))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('bound
	         (let ((start-point (point)) (face 'lsp-isar-font-text-bound))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('skolem
	         (let ((start-point (point)) (face 'lsp-isar-font-text-skolem))
                   (push (cons 'lsp-isar-output-fontification (cons start-point face)) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('sendback ;; TODO handle properly
                 (insert "|" (format "%s" (1+ (length lsp-isar-output-proof-cases-content))) "|: ")
	         (let ((start-point (point)))
	           (let ((str (buffer-substring-no-properties (line-beginning-position) start-point)))
	             (if (cl-search "Try" str)
		         (setq lsp-isar-output-last-seen-prover str)
		       (setq lsp-isar-output-last-seen-prover
		             (concat lsp-isar-output-last-seen-prover "Isar"))))
	           (push (list 'lsp-isar-output-save-sendback start-point) contents)
	           (setq contents (append (dom-children content) contents))))

	        ('bullet
	         (insert "•")
	         (setq contents (append (dom-children content) contents)))

	        ('language
	         (setq contents (append (dom-children content) contents)))

	        ('literal
	         (setq contents (append (dom-children content) contents)))

	        ('delimiter
	         (setq contents (append (dom-children content) contents)))

	        ('entity
	         (setq contents (append (dom-children content) contents)))

	        ('paragraph
	         (setq contents (append (dom-children content) contents)))

	        ('dynamic_fact
	         (setq contents (append (dom-children content) contents)))

	        ('item
	         (setq contents (append (dom-children content) contents))) ;; TODO line break

	        ('break
	         (when (dom-attr content 'width) (insert-char ?\s))
	         (when (dom-attr content 'line) (insert-char ?\n))
                 (dolist (x (dom-children content))
                   (insert (lsp-isar-output-remove-quotes-from-string x))))

	        ('xml_elem
	         (setq contents (append (dom-children content) contents)))

	        ('emacs_isabelle_symbol
	         (let ((symbol (car (dom-children content))))
	           (setq contents (append (cdr (dom-children content)) contents))
	           (insert "\\<" symbol ?>)))

	        ('sub
                 ;; Heuristically find the difference between sub and bsub...esub
	         (let ((children (dom-children content)))
	           (if (and
		        (not (cdr children))
		        (stringp (car children)))
		       (insert (format "\\<^sub>%s" (car children)))
	             (progn
		       (insert "\\<^bsub>")
		       (push "\\<^esub>" contents))
	             (setq contents (append children contents)))))

	        ('sup
                 ;; Heuristically find the difference between sup and bsup...esup
	         ;; but we cannot do better as the information is not transmitted
	         (let ((children (dom-children content)))
	           (if (and
		        (not (cdr children))
		        (stringp (car children)))
		       (insert (format "\\<^sup>%s" (car children)))
	             (insert "\\<^bsup>")
	             (push "\\<^esup>" contents)
	             (setq contents (append children contents)))))

	        ('p nil) ;; libxml odd behaviour

	        (_
	         (if (listp (dom-tag content))
	             (progn
		       (insert (format "%s" (dom-tag content)))
                       (dolist (c (dom-children content))
                         (setf decocations (append (lsp-isar-output-parse-output c)
                                                   decorations))))
	           (insert (format "%s" (dom-tag content))))))))))))
    decorations))

(defun lsp-isar-output-replace-regexp-all-occs (REGEXP TO-STRING)
  "Replace all occurences of REGEXP by TO-STRING.

Lisp equivalent of `replace-regexp' as indicated in the help."
  (goto-char (point-min))
  (while (re-search-forward REGEXP nil t)
    (replace-match TO-STRING nil nil)))

(defun lsp-isar-output--prepare-html ()
  "fixes the html output from Isabelle to match the expectation from emacs"

  (lsp-isar-output-replace-regexp-all-occs "\\\\<\\(\\w*\\)>" "<emacs_isabelle_symbol>\\1</emacs_isabelle_symbol>")
  ;; remove line breaks at beginning
  (lsp-isar-output-replace-regexp-all-occs "\\$\n*<body>\n" "<body>")
  ;; protect spaces and line breaks
  (lsp-isar-output-replace-regexp-all-occs "\s\s\s\s\s"
					   "  ")
  (lsp-isar-output-replace-regexp-all-occs "\n\\( *\\)"
					   "<break line=1>'\\1'</break>")
  (lsp-isar-output-replace-regexp-all-occs "\\(\\w\\)>\\( +\\)<"
					   "\\1><break>'\\2'</break><")
  )

(defun lsp-isar-output--caddddr (x)
  "Return the `car' of the `cdr' of the `cdr' of the `cdr' of the `cdr' of X."
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (cdr (cdr (cdr x))))))

(defun lsp-isar-output-recalculate-sync (lsp-isar-output-current-output-number-res content)
  (setf lsp-isar-output-proof-cases-content nil)
  (let ((decorations nil)
        (lsp-isar-output-last-seen-prover nil)
        (inhibit-message t)
        lsp-isar-have-output?)

    (let ((parsed-content nil))
      (with-temp-buffer
	(when content
	  (insert "$")
	  (insert content)
	  (lsp-isar-output--prepare-html)
	  (setq parsed-content (libxml-parse-html-region (point-min) (point-max)))))

      (with-current-buffer lsp-isar-output-buffer
        (with-inhibited-read-only
         (erase-buffer)
	 (setf decorations (lsp-isar-output-parse-output parsed-content))
	 (goto-char (point-min))
	 (setq lsp-isar-have-output? t)))

      (when (= lsp-isar-output-current-output-number lsp-isar-output-current-output-number-res)
        (cl-incf lsp-isar-output-current-output-number)
        (when lsp-isar-have-output?
	  (with-current-buffer lsp-isar-output-buffer
            (with-inhibited-read-only
	     (dolist (deco decorations)
               (let ((point0 (car deco))
		     (point1 (cadr deco))
		     (face (caddr deco)))
	         (put-text-property point0 point1 'font-lock-face face))))))))))

;; Deactivate font-lock-mode because we do the fontification ourselves anyway.
(defun lsp-isar-output-initialize-output-buffer ()
  "Initialize buffers."
  (setq lsp-isar-output-buffer (get-buffer-create "*lsp-isar-output*"))
  (with-current-buffer lsp-isar-output-buffer
    (visual-line-mode t)
    (hl-line-mode t)
    (read-only-mode t)
    (isar-goal-mode)
    (font-lock-mode nil)))

(lsp-defun lsp-isar-output-update-state-and-output-buffer (_workspace (&lsp-isar:DynamicOutput :content))
  "Launch the thread or timer to update the state and the output
panel with CONTENT."
  (cl-incf lsp-isar-output-current-output-number)

  (when lsp-isar-output-time-before-printing-goal
    (when lsp-isar-output-proof-timer
      (cancel-timer lsp-isar-output-proof-timer))
    (setq lsp-isar-output-proof-timer
	  (run-at-time lsp-isar-output-time-before-printing-goal nil
		       (lambda (content)
			 (lsp-isar-output-recalculate-sync lsp-isar-output-current-output-number content))
		       content))))

(defvar lsp-isar-output--last-message-margin nil)

(defun lsp-isar-output-set-size (size)
  "Resize line length of output buffer."
  (interactive)
  (when (or (null lsp-isar-output--last-message-margin)
            (not (= lsp-isar-output--last-message-margin size)))
    (let ((my-message (lsp-make-notification "PIDE/set_message_margin" (list :value size))))
      (setf lsp-isar-output--last-message-margin size)
      (lsp-send-notification my-message))))

(defun lsp-isar-output-adapt-length ()
  "Adapt the size of the buffer"
  (when lsp-isar-output-buffer
    (let ((cols (window-body-width (get-buffer-window lsp-isar-output-buffer))))
      (lsp-isar-output-set-size (- cols 5)))))

(defun lsp-isar-output-adapt-to-change (&optional _frame)
  (lsp-isar-output-adapt-length))

(add-hook 'window-configuration-change-hook #'lsp-isar-output-adapt-to-change)

(modify-coding-system-alist 'file "*lsp-isar-output*" 'utf-8-auto)

(provide 'lsp-isar-output)

;;; lsp-isar-output.el ends here
